    I had initially made my immediate mode API have 3 things. 
    - Nodes
    - Lists of nodes
    - State.
    
    The problem I was having, was that it's pretty easy to accidentally 
    start conditionally rendering state, and corrupting the data. For example:
    
    function app() {
         const x = imState(newState);
    
         // handle keyboard input
         if (focused) {
             ... big ahh function, lots of things happening here
             if (imValueChanged(blah)) {  // do the thing 
             }
         }
    
         const y = imState(blah bal blah);
    }
    
    When imValueChanged ran, it stored immediate mode state. But all the framework sees is 
         user called imState, lets get them the next state
         user called imState, lets get them the next state
    
    It can't disambiguate the too callsites without something else. 
    I tried adding this notion of a 'type id' - the user just needs to define type ids for all their state, 
    and then we can safely assert against incorrect state access, thus preventing this. One problem - 
    I now need to type in some random number for every imState() invocation.
    
    function app() {
         const x = imState(newState, 123413);
    
         // handle keyboard input
         if (focused) {
             ... big ahh function, lots of things happening here
             if (imValueChanged(blah, 234234)) {  // do the thing 
             }
         }
    
         const y = imState(blah bal blah, 553543);
    }
    
    This is actually a pain in the ass. It occured to me - why am I even doing this? I just want to 
    persist some state. But who said that state needs to be stored in a series of immediate mode function calls?
    Sure, it might make sense to store the UI like this. but maybe this is also nonsense ?
    
    Main benefit is that components can be called one after another if we abstract out state like this.
    
    function app() {
         const s = imState(blah);
    }
    
    Here, we use the function that created the state to disambiguate the state. It works for the most part. 
    I just don't like that we can't define the state inline, and it has to be defined elsewhere.
    So I was looking for alternate solutions. 
    But where is this state stored? This code kinda implies the existance of an immediate mode context above this component
    where the state will live.
    
    Why don't we just make it so that every component can only have 1 state entry? And this state entry can just be an object containing
    everything you might need. The example from above won't work though. Well, sometimes it might. We have no way of preventing people
    from doing this. But what happens to someone'e existing state? Will this just overwrite it? h mmm.

I think this is a good enoguh reason to not go down this road. 
	
	I reckon my state corruption issue will be fixed as long as some of the hooks will check "is this thing I loaded what I expect it to be?". Which is a totally reasonable ask I think. I was getting that for free witht he function approach, but the function approach doesn't let me do inline state, as I said. 

The problem also still exists for normal im nodes, but I've never encountered it, because it's really easy to detect and use the correct
immediate mode patterns when I'm doing UI. It's just these other places. I've added disableIm() and enableIm() just for this.
I can't help but thing there is a simpler and more elegant solution.


	 
